/* autogenerated by Processing revision 1293 on 2024-04-24 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import peasy.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class CorpuriTreiD extends PApplet {



Cube cube = new Cube();
Cylinder cylinder = new Cylinder();
Sphere sphere = new Sphere();
Cone cone = new Cone();
Donut donut = new Donut();
int time;
int currentChoice = -1;
int localKeyPressed = 0;

PeasyCam cam;

public void setup() {
    /* size commented out by preprocessor */;
    cam = new PeasyCam(this, 2000);
    cube.createCube();
    sphere.createSphere();
    time = millis();
}

boolean showMatrixOnly = false;

//TODO: add matrix display to work

public void draw() {
    background(255);
    drawText();
    // Draw 3D scene with PeasyCam
    drawScene();
    // Draw menu overlay
    drawMenu();
}
public void drawScene() {
    ambientLight(255, 255, 255);
    rotateY(frameCount * 0.02f);
    // Draw the current choice
    if (currentChoice != -1) {
        drawObject(currentChoice);
    }

    // Call drawObject based on user input
    if (localKeyPressed == 1 && currentChoice != -1) {
        drawObject(currentChoice);
    }
}

public void keyPressed() {
    localKeyPressed = 1;
    int choice = PApplet.parseInt(key) - 48; // Convert ASCII to integer
    if (choice >= 1 && choice <= 5) {
        currentChoice = choice;
    }
}

public void drawText() {
    cam.beginHUD();
    if (millis() < time + 5000) { // Change 4500 to 5000
        fill(0); // Set text color to black
        rectMode(CORNER); // Set rectangle mode to CORNER
        fill(200); // Set background color to grey
        rect(-850, 760, 3000, 120); // Draw a grey rectangle behind the text
        fill(0); // Set text color to black
        textSize(22);
        text("Click to see wireframe. Hold mouse to rotate. Scroll to change size. ", 20, 450);
    }
    cam.endHUD();
}

public void drawObject(int type) {
    pushMatrix();
    translate(600, 0, 0);
    rotateX(radians(90));
    rotateY(radians(frameCount * 1.2f));

    switch (type) {
        case 1:
            if (!showMatrixOnly) {
                cube.showCube();
            } else {
                cube.showMatrix();
            }
            break;
        case 2:
                cylinder.showCylinder();
            break;
        case 3:
            if (!showMatrixOnly) {
                sphere.showSphere();
            } else {
                sphere.showMatrix();
            }
            break;
        case 4:
            if (!showMatrixOnly) {
                cone.showCone();
            } else {
                cone.showCone();
            }
            break;
        case 5:
            if (!showMatrixOnly) {
                donut.showDonut();
            } else {
                donut.showMatrix();
            }
            break;
        default:
            println("Invalid choice");
            break;
    }
    popMatrix();
}

public void drawMenu() {
    // Draw menu in 2D space
    cam.beginHUD();
    textSize(30);
    fill(0);
    text("Choose an object to draw:", 20, 50); // Move menu to top left corner
    text("1. Cube", 20, 100); // Adjust position
    text("2. Cylinder", 20, 150); // Adjust position
    text("3. Sphere", 20, 200); // Adjust position
    text("4. Cone", 20, 250); // Adjust position
    text("5. Donut", 20, 300); // Adjust position
    cam.endHUD();
}

public void mousePressed() {
    if (mouseButton == LEFT) {
        showMatrixOnly = !showMatrixOnly;
    }
    if (mouseButton == RIGHT) {
        showMatrixOnly = false;
    }
}
PShape coneShape;

class Cone {
    public void showCone() {
        translate(width / 2, height / 2, 0);  
        stroke(0, 0, 100);
        fill(0, 0, 100);
        rotateX(PI / 2);
        rotateZ( -PI / 6);
        
        beginShape();
        vertex( -100, -100, -100);
        vertex(100, -100, -100);
        vertex(0,    0,  100);
        
        vertex(100, -100, -100);
        vertex(100,  100, -100);
        vertex(0,    0,  100);
        
        vertex(100, 100, -100);
        vertex( -100, 100, -100);
        vertex(0,   0,  100);
        
        vertex( -100,  100, -100);
        vertex( -100, -100, -100);
        vertex(0,    0,  100);
        endShape();
    }
    
    public void showMatrix() {
        translate(width / 2, height / 2, 0);  
        stroke(0, 0, 100);
        rotateX(PI / 2);
        rotateZ( -PI / 6);
        
        beginShape();
        vertex( -100, -100, -100);
        vertex(100, -100, -100);
        vertex(0,    0,  100);
        
        vertex(100, -100, -100);
        vertex(100,  100, -100);
        vertex(0,    0,  100);
        
        vertex(100, 100, -100);
        vertex( -100, 100, -100);
        vertex(0,   0,  100);
        
        vertex( -100,  100, -100);
        vertex( -100, -100, -100);
        vertex(0,    0,  100);
        endShape();
    }
}
PShape cubeShape;

class Cube {
    public void createCube() {
        fill(0, 0, 100);
        noStroke();
        cubeShape = createShape(BOX, 500);
    }
    
    public void showCube() {
        shape(cubeShape);
    }
    
    public void showMatrix() {
        stroke(0, 0, 100);
        cubeShape.disableStyle();
        shape(cubeShape);
    }
}
PShape cylinderShape;

class Cylinder {
    public void showCylinder()
    {
        int sides = 60;
        float r1 = 80;
        float r2 = 80;
        float h = 320;
        float angle = 360 / sides;
        float halfHeight = h / 2;
        // top
        rotateX(PI / 2);
        rotateZ( -PI / 6);
        beginShape();
        for (int i = 0; i < sides; i++) {
            float x = cos(radians(i * angle)) * r1;
            float y = sin(radians(i * angle)) * r1;
            vertex(x, y, -halfHeight);
        }
        endShape(CLOSE);
        // bottom
        beginShape();
        for (int i = 0; i < sides; i++) {
            float x = cos(radians(i * angle)) * r2;
            float y = sin(radians(i * angle)) * r2;
            vertex(x, y, halfHeight);
        }
        endShape(CLOSE);
        // draw body
        beginShape(TRIANGLE_STRIP);
        for (int i = 0; i < sides + 1; i++) {
            float x1 = cos(radians(i * angle)) * r1;
            float y1 = sin(radians(i * angle)) * r1;
            float x2 = cos(radians(i * angle)) * r2;
            float y2 = sin(radians(i * angle)) * r2;
            vertex(x1, y1, -halfHeight);
            vertex(x2, y2, halfHeight);
        }
        endShape(CLOSE);
    }
}
interface RectType {
  void drawRect(PVector aPos, PVector bPos, PVector cPos, PVector dPos);
}

class Donut {
  public void showDonut() {
    showDonutType(new RectFill());
  }

  public void showMatrix() {
    showDonutType(new RectStroke());
  }

  public void showDonutType(RectType rectType) {
    int nB = 6, nS = 8, iRad = 150, jRad = 100;
    float radB = TWO_PI / nB;
    float radS = TWO_PI / nS;

    float frameNum = frameCount * 0.005f;

    for (float i = 0; i < TWO_PI; i += radB) {
      PVector iPos = new PVector(sin(i + frameNum), 0, cos(i + frameNum));
      PVector NiPos = new PVector(sin(i + radB + frameNum), 0, cos(i + radB + frameNum));

      for (float j = 0; j < TWO_PI; j += radS) {
        PVector jPos = new PVector(sin(j + frameNum), cos(j + frameNum), sin(j + frameNum));
        PVector NjPos = new PVector(sin(j + radS + frameNum), cos(j + radS + frameNum), sin(j + radS + frameNum));

        PVector posA = new PVector(iRad * iPos.x + jRad * iPos.x * jPos.x,
                                   iRad * iPos.y + jRad * jPos.y,
                                   iRad * iPos.z + jRad * iPos.z * jPos.z);

        PVector posB = new PVector(iRad * iPos.x + jRad * iPos.x * NjPos.x,
                                   iRad * iPos.y + jRad * NjPos.y,
                                   iRad * iPos.z + jRad * iPos.z * NjPos.z);

        PVector posC = new PVector(iRad * NiPos.x + jRad * NiPos.x * NjPos.x,
                                   iRad * NiPos.y + jRad * NjPos.y - noise(j),
                                   iRad * NiPos.z + jRad * NiPos.z * NjPos.z);

        PVector posD = new PVector(iRad * NiPos.x + jRad * NiPos.x * jPos.x,
                                   iRad * NiPos.y + jRad * jPos.y - noise(j),
                                   iRad * NiPos.z + jRad * NiPos.z * jPos.z);

        rectType.drawRect(posA, posB, posC, posD);
      }
    }
  }
}

class RectFill implements RectType {
  public void drawRect(PVector aPos, PVector bPos, PVector cPos, PVector dPos) {
    fill(0, 0, 100);
    beginShape();
    vertex(aPos.x, aPos.y, aPos.z);
    vertex(bPos.x, bPos.y, bPos.z);
    vertex(cPos.x, cPos.y, cPos.z);
    vertex(dPos.x, dPos.y, dPos.z);
    endShape(CLOSE);
  }
}

class RectStroke implements RectType {
  public void drawRect(PVector aPos, PVector bPos, PVector cPos, PVector dPos) {
    beginShape();
    vertex(aPos.x, aPos.y, aPos.z);
    vertex(bPos.x, bPos.y, bPos.z);
    vertex(cPos.x, cPos.y, cPos.z);
    vertex(dPos.x, dPos.y, dPos.z);
    endShape(CLOSE);
  }
}
PShape spehereShape;

class Sphere{
  public void createSphere(){
    fill(0, 0, 100);
    noStroke();
    spehereShape = createShape(SPHERE, 100);
  }
  
  public void showSphere(){
    shape(spehereShape);
  }

  public void showMatrix() {
        stroke(0, 0, 100);
        spehereShape.disableStyle();
        shape(spehereShape);
    }
}


  public void settings() { size(852, 480, P3D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "CorpuriTreiD" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
