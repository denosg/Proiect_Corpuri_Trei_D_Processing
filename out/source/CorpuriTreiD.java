/* autogenerated by Processing revision 1293 on 2024-04-21 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import peasy.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class CorpuriTreiD extends PApplet {



Cube cube = new Cube();
Cylinder cylinder = new Cylinder();
Sphere sphere = new Sphere();
Cone cone = new Cone();
Donut donut = new Donut();

PeasyCam cam;

public void setup() {
    /* size commented out by preprocessor */;
    cam = new PeasyCam(this, 2000);
    cube.createCube();
    sphere.createSphere();
}

boolean showMatrixOnly = false;

public void draw() {
    background(255);
    ambientLight(255, 255, 255);
    rotateY(frameCount * 0.02f);
    pushMatrix();
    rotateX(radians(25));
    rotateY(radians(frameCount * 0.1f));
    
    if (!showMatrixOnly) {
        cube.showCube();
    } else {
        cube.showMatrix();
    }
    
    translate(1200, 0, 0);
    rotateX(radians(45));
    rotateY(radians(frameCount));
    cone.showCone();
    popMatrix();
    pushMatrix();
    translate(1000,0,0);
    rotate(radians(180));
    rotate(radians(frameCount * 1.09f));
    cylinder.showCylinder();
    popMatrix();
    //donut
    translate(800, 200);
    rotateX(PI * 0.75f);
    rotate(frameCount * 0.01f);
    noFill();
    stroke(0, 0, 100);
    strokeWeight(1.0f);
    if (!showMatrixOnly) {
        donut.showDonut();
    } else {
        donut.showMatrix();
    }
    pushMatrix();
    translate(600,0,0);
    rotateX(radians(90));
    rotateY(radians(frameCount * 1.2f));
    
    if (!showMatrixOnly) {
        sphere.showSphere();
    } else {
        sphere.showMatrix();
    }
    popMatrix();  
}

public void mousePressed() {
    if (mouseButton == LEFT) {
        showMatrixOnly = !showMatrixOnly;
    }
    if (mouseButton == RIGHT) {
        showMatrixOnly = false;
    }
}
PShape coneShape;

class Cone {
    public void showCone() {
        translate(width / 2, height / 2, 0);  
        stroke(0, 0, 100);
        fill(0, 0, 100);
        rotateX(PI / 2);
        rotateZ( -PI / 6);
        
        beginShape();
        vertex( -100, -100, -100);
        vertex(100, -100, -100);
        vertex(0,    0,  100);
        
        vertex(100, -100, -100);
        vertex(100,  100, -100);
        vertex(0,    0,  100);
        
        vertex(100, 100, -100);
        vertex( -100, 100, -100);
        vertex(0,   0,  100);
        
        vertex( -100,  100, -100);
        vertex( -100, -100, -100);
        vertex(0,    0,  100);
        endShape();
    }
    
    public void showMatrix() {
        translate(width / 2, height / 2, 0);  
        stroke(0, 0, 100);
        rotateX(PI / 2);
        rotateZ( -PI / 6);
        
        beginShape();
        vertex( -100, -100, -100);
        vertex(100, -100, -100);
        vertex(0,    0,  100);
        
        vertex(100, -100, -100);
        vertex(100,  100, -100);
        vertex(0,    0,  100);
        
        vertex(100, 100, -100);
        vertex( -100, 100, -100);
        vertex(0,   0,  100);
        
        vertex( -100,  100, -100);
        vertex( -100, -100, -100);
        vertex(0,    0,  100);
        endShape();
    }
}
PShape cubeShape;

class Cube {
    public void createCube() {
        fill(0, 0, 100);
        noStroke();
        cubeShape = createShape(BOX, 500);
    }
    
    public void showCube() {
        shape(cubeShape);
    }
    
    public void showMatrix() {
        stroke(0, 0, 100);
        cubeShape.disableStyle();
        shape(cubeShape);
    }
}
PShape cylinderShape;

class Cylinder {
    public void showCylinder()
    {
        int sides = 60;
        float r1 = 80;
        float r2 = 80;
        float h = 320;
        float angle = 360 / sides;
        float halfHeight = h / 2;
        // top
        rotateX(PI / 2);
        rotateZ( -PI / 6);
        beginShape();
        for (int i = 0; i < sides; i++) {
            float x = cos(radians(i * angle)) * r1;
            float y = sin(radians(i * angle)) * r1;
            vertex(x, y, -halfHeight);
        }
        endShape(CLOSE);
        // bottom
        beginShape();
        for (int i = 0; i < sides; i++) {
            float x = cos(radians(i * angle)) * r2;
            float y = sin(radians(i * angle)) * r2;
            vertex(x, y, halfHeight);
        }
        endShape(CLOSE);
        // draw body
        beginShape(TRIANGLE_STRIP);
        for (int i = 0; i < sides + 1; i++) {
            float x1 = cos(radians(i * angle)) * r1;
            float y1 = sin(radians(i * angle)) * r1;
            float x2 = cos(radians(i * angle)) * r2;
            float y2 = sin(radians(i * angle)) * r2;
            vertex(x1, y1, -halfHeight);
            vertex(x2, y2, halfHeight);
        }
        endShape(CLOSE);
    }
}
interface RectType {
  void drawRect(PVector aPos, PVector bPos, PVector cPos, PVector dPos);
}

class Donut {
  public void showDonut() {
    showDonutType(new RectFill());
  }

  public void showMatrix() {
    showDonutType(new RectStroke());
  }

  public void showDonutType(RectType rectType) {
    int nB = 6, nS = 8, iRad = 150, jRad = 100;
    float radB = TWO_PI / nB;
    float radS = TWO_PI / nS;

    float frameNum = frameCount * 0.005f;

    for (float i = 0; i < TWO_PI; i += radB) {
      PVector iPos = new PVector(sin(i + frameNum), 0, cos(i + frameNum));
      PVector NiPos = new PVector(sin(i + radB + frameNum), 0, cos(i + radB + frameNum));

      for (float j = 0; j < TWO_PI; j += radS) {
        PVector jPos = new PVector(sin(j + frameNum), cos(j + frameNum), sin(j + frameNum));
        PVector NjPos = new PVector(sin(j + radS + frameNum), cos(j + radS + frameNum), sin(j + radS + frameNum));

        PVector posA = new PVector(iRad * iPos.x + jRad * iPos.x * jPos.x,
                                   iRad * iPos.y + jRad * jPos.y,
                                   iRad * iPos.z + jRad * iPos.z * jPos.z);

        PVector posB = new PVector(iRad * iPos.x + jRad * iPos.x * NjPos.x,
                                   iRad * iPos.y + jRad * NjPos.y,
                                   iRad * iPos.z + jRad * iPos.z * NjPos.z);

        PVector posC = new PVector(iRad * NiPos.x + jRad * NiPos.x * NjPos.x,
                                   iRad * NiPos.y + jRad * NjPos.y - noise(j),
                                   iRad * NiPos.z + jRad * NiPos.z * NjPos.z);

        PVector posD = new PVector(iRad * NiPos.x + jRad * NiPos.x * jPos.x,
                                   iRad * NiPos.y + jRad * jPos.y - noise(j),
                                   iRad * NiPos.z + jRad * NiPos.z * jPos.z);

        rectType.drawRect(posA, posB, posC, posD);
      }
    }
  }
}

class RectFill implements RectType {
  public void drawRect(PVector aPos, PVector bPos, PVector cPos, PVector dPos) {
    fill(0, 0, 100);
    beginShape();
    vertex(aPos.x, aPos.y, aPos.z);
    vertex(bPos.x, bPos.y, bPos.z);
    vertex(cPos.x, cPos.y, cPos.z);
    vertex(dPos.x, dPos.y, dPos.z);
    endShape(CLOSE);
  }
}

class RectStroke implements RectType {
  public void drawRect(PVector aPos, PVector bPos, PVector cPos, PVector dPos) {
    beginShape();
    vertex(aPos.x, aPos.y, aPos.z);
    vertex(bPos.x, bPos.y, bPos.z);
    vertex(cPos.x, cPos.y, cPos.z);
    vertex(dPos.x, dPos.y, dPos.z);
    endShape(CLOSE);
  }
}
PShape spehereShape;

class Sphere{
  public void createSphere(){
    fill(0, 0, 100);
    noStroke();
    spehereShape = createShape(SPHERE, 100);
  }
  
  public void showSphere(){
    shape(spehereShape);
  }

  public void showMatrix() {
        stroke(0, 0, 100);
        spehereShape.disableStyle();
        shape(spehereShape);
    }
}


  public void settings() { size(852, 480, P3D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "CorpuriTreiD" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
